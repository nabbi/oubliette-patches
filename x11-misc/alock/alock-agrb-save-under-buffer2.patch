diff --git a/.gitignore b/.gitignore
index 5f45b5d..3c937e7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,6 +21,7 @@
 *.i*86
 *.x86_64
 *.hex
+/src/alock
 
 # Autotools
 /autom4te.cache/
@@ -34,6 +35,13 @@
 Makefile.in
 config.h.in
 *~
+/Makefile
+/config.h
+/config.status
+/stamp-h1
+/doc/Makefile
+/src/Makefile
+/src/.deps/
 
 *.d
 config.mk
diff --git a/src/main.c b/src/main.c
index e4cb32e..af6bc9a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -177,7 +177,8 @@ static void setBacklightBrightness(float value) {
 
 /* Lock current display and grab pointer and keyboard. On successful
  * lock this function returns 0, otherwise -1. */
-static int lockDisplay(Display *display, struct aModules *modules) {
+static int lockDisplay(Display *display, struct aModules *modules,
+        Window **out_bgwins, int *out_bgcount) {
 
     Window window;
     Cursor cursor;
@@ -187,6 +188,9 @@ static int lockDisplay(Display *display, struct aModules *modules) {
 
     int bgcount = 0;
 
+    *out_bgwins = NULL;
+    *out_bgcount = 0;
+
     if (bgwins == NULL) {
         fprintf(stderr, "alock: error window out of memory\n");
         return -1;
@@ -281,27 +285,23 @@ static int lockDisplay(Display *display, struct aModules *modules) {
         XSync(display, False);
     }
 
-    free(bgwins);
-
     /* grab pointer and keyboard from the default screen */
     window = DefaultRootWindow(display);
 
     /*
-     * Grab pointer first without a custom cursor, then switch to the real cursor.
-     * This reduces "save-under" capturing pre-lock pixels on some servers/drivers.
+     * Grab pointer with the module cursor.  Background windows have already
+     * been mapped, raised, and painted (verified above), so the save-under
+     * buffer will capture lock-screen content rather than the desktop.
      */
+    cursor = modules->cursor->getcursor();
     if (XGrabPointer(display, window, False, 0,
                 GrabModeAsync, GrabModeAsync, None,
-                None, CurrentTime) != GrabSuccess) {
+                cursor, CurrentTime) != GrabSuccess) {
         fprintf(stderr, "error: grab pointer failed\n");
+        free(bgwins);
         return -1;
     }
 
-    XSync(display, False);
-
-    cursor = modules->cursor->getcursor();
-    XChangeActivePointerGrab(display, 0, cursor, CurrentTime);
-
     /* try to grab 2 times, another process (windowmanager) may have grabbed
      * the keyboard already */
     if (XGrabKeyboard(display, window, True, GrabModeAsync, GrabModeAsync,
@@ -310,14 +310,18 @@ static int lockDisplay(Display *display, struct aModules *modules) {
         if (XGrabKeyboard(display, window, True, GrabModeAsync, GrabModeAsync,
                     CurrentTime) != GrabSuccess) {
             fprintf(stderr, "error: grab keyboard failed\n");
+            free(bgwins);
             return -1;
         }
     }
 
+    *out_bgwins = bgwins;
+    *out_bgcount = bgcount;
     return 0;
 }
 
-static void eventLoop(Display *display, struct aModules *modules) {
+static void eventLoop(Display *display, struct aModules *modules,
+        Window *bgwins, int bgcount) {
 
     XEvent ev;
     KeySym ks;
@@ -359,6 +363,70 @@ static void eventLoop(Display *display, struct aModules *modules) {
             /* block until any key press event arrives */
             XMaskEvent(display, KeyPressMask | StructureNotifyMask, &ev);
 
+            /*
+             * We just woke from idle.  After resume from system sleep the
+             * X server's cursor sprite backing store may contain stale
+             * framebuffer content from before suspend.  With ARGB cursors
+             * (which have transparency) this old desktop content would be
+             * visible through the cursor.
+             *
+             * Fix: swap the grabbed cursor to a blank (invisible) one.
+             * This forces the X server to discard the ARGB cursor sprite
+             * and its stale backing store.  Repaint the backgrounds, then
+             * swap back to the ARGB cursor so the server captures a fresh
+             * backing store from the now-clean framebuffer.
+             *
+             * An XGetImage round-trip acts as a GPU fence, ensuring the
+             * cleared content has reached the framebuffer before the ARGB
+             * cursor sprite is recreated.
+             *
+             * Using XChangeActivePointerGrab keeps the grab held at all
+             * times â€” no window underneath is ever briefly accessible.
+             */
+            if (bgcount > 0) {
+                static Cursor blank = None;
+                if (blank == None) {
+                    char d = 0;
+                    Pixmap pm = XCreateBitmapFromData(display,
+                            DefaultRootWindow(display), &d, 1, 1);
+                    XColor c = { 0 };
+                    blank = XCreatePixmapCursor(display, pm, pm,
+                            &c, &c, 0, 0);
+                    XFreePixmap(display, pm);
+                }
+
+                XChangeActivePointerGrab(display, 0, blank, CurrentTime);
+                XSync(display, False);
+
+                for (int j = 0; j < bgcount; j++) {
+                    XRaiseWindow(display, bgwins[j]);
+                    XClearWindow(display, bgwins[j]);
+                }
+                XSync(display, False);
+
+                XImage *fence = XGetImage(display, bgwins[0],
+                        0, 0, 1, 1, AllPlanes, ZPixmap);
+                if (fence)
+                    XDestroyImage(fence);
+
+                /*
+                 * With software-rendered cursors the X server caches
+                 * the pixels underneath the sprite ("save-under").
+                 * That cache is only refreshed on pointer movement,
+                 * NOT when the underlying window is repainted.  Nudge
+                 * the pointer so the server re-captures its save-under
+                 * from the now-clean background before we restore the
+                 * ARGB cursor.
+                 */
+                XWarpPointer(display, None, None, 0, 0, 0, 0, 1, 0);
+                XSync(display, False);
+                XWarpPointer(display, None, None, 0, 0, 0, 0, -1, 0);
+                XSync(display, False);
+
+                Cursor cur = modules->cursor->getcursor();
+                XChangeActivePointerGrab(display, 0, cur, CurrentTime);
+            }
+
 #if WITH_XBLIGHT
             /* restore original backlight brightness value */
             if (modules->backlight != -1)
@@ -493,14 +561,9 @@ static void eventLoop(Display *display, struct aModules *modules) {
             debug("received configure notify event");
             break;
 
-#if 0
-        case Expose:
-            XClearWindow(dpy, ((XExposeEvent*)&ev)->window);
-            break;
-#endif
-
         }
     }
+
 }
 
 int main(int argc, char **argv) {
@@ -731,11 +794,14 @@ int main(int argc, char **argv) {
 
     /* raise our background window and grab input, if this action has failed,
      * we are not able to lock the screen, then we're fucked... */
-    if (lockDisplay(display, &modules))
+    Window *bgwins = NULL;
+    int bgcount = 0;
+
+    if (lockDisplay(display, &modules, &bgwins, &bgcount))
         goto return_failure;
 
     debug("entering main event loop");
-    eventLoop(display, &modules);
+    eventLoop(display, &modules, bgwins, bgcount);
 
     retval = EXIT_SUCCESS;
     goto return_success;
@@ -745,6 +811,7 @@ return_failure:
 
 return_success:
 
+    free(bgwins);
     modules.auth->m.free();
     modules.cursor->m.free();
     modules.input->m.free();
