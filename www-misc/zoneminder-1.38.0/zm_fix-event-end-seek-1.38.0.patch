diff --git a/src/zm_eventstream.cpp b/src/zm_eventstream.cpp
index fab46ae83..45224c810 100644
--- a/src/zm_eventstream.cpp
+++ b/src/zm_eventstream.cpp
@@ -790,6 +790,10 @@ bool EventStream::checkEventLoaded() {
     Debug(2, "Pausing because mode is %s", StreamMode_Strings[mode].c_str());
     curr_frame_id = curr_frame_id <= 0 ? 1 : event_data->last_frame_id;
     paused = true;
+    // Reset last_frame_sent so the next loop iteration sends a keepalive
+    // immediately, rather than leaving a 5-second gap (MAX_STREAM_DELAY)
+    // during which the HTTP connection can time out and break the pipe.
+    last_frame_sent = {};
   }
   return false;
 }  // void EventStream::checkEventLoaded()
@@ -973,6 +977,7 @@ void EventStream::runStream() {
   // Has to go here, at the moment, for sendFrame(delta).
   Microseconds delta = Microseconds(0);
 
+  try {
   while (!zm_terminate) {
     now = start = std::chrono::steady_clock::now();
 
@@ -1160,7 +1165,9 @@ void EventStream::runStream() {
 
         // This next bit is to determine if we are in the current event time wise
         // and whether to show an image saying how long until the next event.
-        if (replay_rate > 0) {
+        if (event_data->frames.empty()) {
+          Debug(1, "New event has no frames yet, skipping time_to_event calculation");
+        } else if (replay_rate > 0) {
           // This doesn't make sense unless we have hit the end of the event.
           time_to_event = event_data->frames[0].timestamp - curr_stream_time;
           Debug(1, "replay rate (%d) time_to_event (%f s) = frame timestamp (%f s) - curr_stream_time (%f s)",
@@ -1180,6 +1187,13 @@ void EventStream::runStream() {
       }  // end if checkEventLoaded
     }  // end scope for lock
   }  // end while ! zm_terminate
+  } catch (const std::exception &e) {
+    Error("Exception in runStream: %s", e.what());
+    zm_terminate = true;
+  } catch (...) {
+    Error("Unknown exception in runStream");
+    zm_terminate = true;
+  }
 
   if (type == STREAM_MPEG) {
     delete vid_stream;
diff --git a/src/zm_stream.cpp b/src/zm_stream.cpp
index f958bcdff..24abe495f 100644
--- a/src/zm_stream.cpp
+++ b/src/zm_stream.cpp
@@ -114,6 +114,7 @@ void StreamBase::updateFrameRate(double fps) {
 
 void StreamBase::checkCommandQueue() {
   while (!zm_terminate) {
+    try {
     // Update modified time of the socket .lock file so that we can tell which ones are stale.
     if (now - last_comm_update > Hours(1)) {
       touch(sock_path_lock);
@@ -139,6 +140,13 @@ void StreamBase::checkCommandQueue() {
       // Perfectly valid if only getting a snapshot
       Debug(1, "No sd in checkCommandQueue, comms not open.");
     }
+    } catch (const std::exception &e) {
+      Error("Exception in checkCommandQueue: %s", e.what());
+      zm_terminate = true;
+    } catch (...) {
+      Error("Unknown exception in checkCommandQueue");
+      zm_terminate = true;
+    }
   } // end while !zm_terminate
 }  // end void StreamBase::checkCommandQueue()
 
diff --git a/src/zms.cpp b/src/zms.cpp
index 9ff4be502..dddc03e33 100644
--- a/src/zms.cpp
+++ b/src/zms.cpp
@@ -24,6 +24,7 @@
 #include "zm_monitorstream.h"
 #include "zm_eventstream.h"
 #include "zm_fifo_stream.h"
+#include <csignal>
 #include <iomanip>
 #include <sstream>
 #include <string>
@@ -276,6 +277,10 @@ int main(int argc, const char *argv[], char **envp) {
   Image::Initialise();
   zmSetDefaultTermHandler();
   zmSetDefaultDieHandler();
+  // Ignore SIGPIPE so broken HTTP connections return EPIPE from write()
+  // instead of killing the process. Without this, the 5-second keepalive
+  // gap after event end causes zms to die on the next stdout write.
+  std::signal(SIGPIPE, SIG_IGN);
 
   setbuf(stdout, nullptr);
   if ( nph ) {
diff --git a/web/skins/classic/views/js/event.js b/web/skins/classic/views/js/event.js
index 8d6121e4a..908ddcf4b 100644
--- a/web/skins/classic/views/js/event.js
+++ b/web/skins/classic/views/js/event.js
@@ -30,6 +30,7 @@ var streamCmdInterval = null;
 var streamStatus = null;
 var lastEventId = 0;
 var zmsBroke = false; //Use alternate navigation if zms has crashed
+var pendingSeek = null; // Queued seek offset for after zms stream restart
 var wasHidden = false;
 var availableTags = [];
 var selectedTags = [];
@@ -444,6 +445,13 @@ function getCmdResponse(respObj, respText) {
 
   zmsBroke = false;
 
+  // Execute any pending seek queued during a stream restart
+  if (pendingSeek !== null) {
+    const offset = pendingSeek;
+    pendingSeek = null;
+    streamSeek(offset);
+  }
+
   streamStatus = respObj.status;
   if (!streamStatus) {
     console.log('No status in respObj');
@@ -823,7 +831,18 @@ function streamSeek(offset) {
   if (vid) {
     vid.currentTime(offset);
   } else {
-    streamReq({command: CMD_SEEK, offset: offset});
+    if (zmsBroke) {
+      // zms has exited; restart stream and queue seek for when it's ready
+      pendingSeek = offset;
+      const img = document.getElementById('evtStream');
+      const url = new URL(img.src);
+      url.searchParams.set('scale', currentScale);
+      img.src = '';
+      img.src = url.href;
+      zmsBroke = false;
+    } else {
+      streamReq({command: CMD_SEEK, offset: offset});
+    }
   }
 }
 
